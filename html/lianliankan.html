<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<title>JS连连看源码完美注释版</title>
<style>
	body,p,div,table, h1, h2, h3,h4,h5,h6 {margin: 0;padding: 0}
	body {font: 12px/20px tahoma,arail;}
	table{ border-collapse: collapse; border-spacing: 0}
	td { width:36px;height:36px; border: solid #ccc 1px;cursor: pointer}
		td img { height: 30px; width: 30px;	border: solid #fff 3px;vertical-align: middle}
	h4,h5,h6 {font-size: 12px}
	a {cursor: pointer;}

	h2 {clear: both}
	h6 {margin-top: 20px}

	.clear {zoom:1;}
	.clear:after {content: "\20";display: block;clear: both}
	.r-f {float: right}

	.btn {padding:5px 20px;background: #f60;border:0 none;color: #fff;font-size: 14px;font-weight: 700;
			border-radius: 5px;
			box-shadow: 0 0 2px #f60}

	#page {margin: auto;width: 578px}

	#progress {margin:0 0 20px;width:545px;border: 1px solid #090}
	#progress-inner {height:16px;width: 100%;background: #080}

	form {margin-top:20px;width: 518px}
	
	#submit-score {display: none}
	#score {display:inline-block;width:80px;font-size: 18px;font-weight: 700}

	#tbl-wrap {position: relative;}
		#overlay {position: absolute;top:0;left:0;width:548px;height:470px;background:#000;background: rgba(0, 0, 0, .3);
				filter:alpha(opacity=30);}
		#btn-play {position: absolute;z-index:2;top:100px;left: 50%;margin-left: -50px}
		#btn-play.started {top:-100px; right: 30px;left:auto; margin:0;width:30px;}

</style>

</head>
<body onload="init();">
	<div id="page">
		<h2>js连连看完美注释版</h2>

		<form action="" method="post">

			<input id="score-param" type="hidden" value="" />
			<span>得分：</span><em id="score">0</em>
			<input id="submit-score" type="submit" value="提交分数" class="btn"  />
		</form>

		<div id="area">
			<h6>剩余时间：</h6>
			<div id="progress"><p id="progress-inner"></p></div>
			
			<div id="tbl-wrap">
				<a id="btn-play" class="btn r-f" onclick="play(this);">开始</a>
				<p id="overlay"></p>
				<table id="tbl"></table>
			</div>
		</div>
			
	</div>

	<script>
/**
* js连连看
**/

//以下部分为路径搜索算法部分,与表现层无关

//全局变量
var X = 16;//总行数
var Y = 14;//总列数
var types = 15;//图形种类

//布局矩阵
//为了算法方便，矩阵的第一行，第一列，最后一行，最后一列都标注为0，天然通路。
var arr = new Array(Y);
var tbl;//显示布局的table元素

var p1 = null;//搜索路径用的第1个点的坐标
var p2 = null;//搜索路径用的第2个点的坐标
var e1 = null;//第1个点对应的元素
var e2 = null;//第2个点对应的元素

//路径搜索，给出两个点，搜索出通路
//通路用可连通的点表示
function getPath(p1, p2){
	//开始搜索前对p1,p2排序，使p2尽可能的在p1的右下方。
	//这样做可以简化算法
	if(p1.x>p2.x){
		var t = p1; 
		p1 = p2;
		p2 = t;	
	}
	else if(p1.x==p2.x){
		if(p1.y>p2.y){
			var t = p1; 
			p1 = p2;
			p2 = t;	
		}
	}
	//通过分析连连看中两点之间的位置关系，逐步由简到难分析每一种类型
	//第一种类型， 两点是否在一条直线上，而且两点之间可直线连通
	if((onlineY(p1, p2)||onlineX(p1, p2)) && hasLine(p1, p2)){
		status = 'type 1';
		score.step = score.type['oneline'];
		return [p1,p2];
	}
	//第二种类型， 如果两点中任何一个点被全包围，则不通。
	if( !isEmpty({x:p1.x, y:p1.y+1}) && !isEmpty({x:p1.x, y:p1.y-1}) && !isEmpty({x:p1.x-1, y:p1.y}) && !isEmpty({x:p1.x+1, y:p1.y}) ){
		status = 'type 2';
		return null;
	}
	if( !isEmpty({x:p2.x, y:p2.y+1}) && !isEmpty({x:p2.x, y:p2.y-1}) && !isEmpty({x:p2.x-1, y:p2.y}) && !isEmpty({x:p2.x+1, y:p2.y}) ){
		status = 'type 2';
		return null;
	}
	//第三种类型， 两点在一条直线上，但是不能直线连接
	var pt0, pt1, pt2, pt3;
	//如果都在x轴，则自左至右扫描可能的路径，
	//每次构造4个顶点pt0, pt1, pt2, pt3，然后看他们两两之间是否连通
	if(onlineX(p1, p2)){
		for(var i=0; i<Y; i++){
			if(i==p1.y){
				continue;
			}
			pt0 = p1;
			pt1 = {x: p1.x, y: i};
			pt2 = {x: p2.x, y: i};
			pt3 = p2;
			//如果顶点不为空，则该路不通。
			if(!isEmpty(pt1) || !isEmpty(pt2)){
				continue;
			}
			if( hasLine(pt0, pt1) && hasLine(pt1, pt2) && hasLine(pt2, pt3) ){
				status = '(x:' + pt0.x + ',y:' + pt0.y + ')' + ', (x:' + pt1.x + ',y:' + pt1.y + ')' + ', (x:' + pt2.x + ',y:' + pt2.y + ')' + ', (x:' + pt3.x + ',y:' + pt3.y + ')';
				score.step = score.type['onlineX'];
				return [pt0, pt1, pt2, pt3];
			}
		}
	}
	//如果都在y轴，则自上至下扫描可能的路径，
	//每次构造4个顶点pt0, pt1, pt2, pt3，然后看他们两两之间是否连通
	if(onlineY(p1, p2)){
		for(var j=0; j<X; j++){
			if(j==p1.x){
				continue;	
			}
			pt0 = p1;
			pt1 = {x:j, y:p1.y};
			pt2 = {x:j, y:p2.y};
			pt3 = p2;
			//如果顶点不为空，则该路不通。
			if(!isEmpty(pt1) || !isEmpty(pt2)){
				continue;
			}
			if( hasLine(pt0, pt1) && hasLine(pt1, pt2) && hasLine(pt2, pt3) ){
				status = '(x:' + pt0.x + ',y:' + pt0.y + ')' + ', (x:' + pt1.x + ',y:' + pt1.y + ')' + ', (x:' + pt2.x + ',y:' + pt2.y + ')' + ', (x:' + pt3.x + ',y:' + pt3.y + ')';
				score.step = score.type['onlineY'];
				return [pt0, pt1, pt2, pt3];
			}
		}
	}
	//第四种类型， 两点不在一条直线上。
	//先纵向扫描可能的路径
	//同样，每次构造4个顶点，看是否可通
	for(var k=0; k<Y; k++){
			pt0 = p1;
			pt1 = {x:p1.x, y:k};
			pt2 = {x:p2.x, y:k};
			pt3 = p2;
			status = '(x:' + pt0.x + ',y:' + pt0.y + ')' + ', (x:' + pt1.x + ',y:' + pt1.y + ')' + ', (x:' + pt2.x + ',y:' + pt2.y + ')' + ', (x:' + pt3.x + ',y:' + pt3.y + ')';
			//特殊情况，如果pt0和pt1重合
			if(equal(pt0,pt1)){
				//如果pt2不为空，则此路不通
				if(!isEmpty(pt2)){
					continue;
				}
				if( hasLine(pt1, pt2) && hasLine(pt2, pt3) ){
					score.step = score.type['nolineX'];
					return [pt1, pt2, pt3];
				}
				else{
					continue;
				}
			}
			//特殊情况，如果pt2和pt3重合
			else if(equal(pt2,pt3)){
				//如果pt1不为空，则此路不通
				if(!isEmpty(pt1)){
					continue;
				}
				if( hasLine(pt0, pt1) && hasLine(pt1, pt2) ){
					score.step = score.type['nolineY'];
					return [pt0, pt1, pt2];
				}
				else{
					continue;
				}
			}
			//如果pt1, pt2都不为空,则不通
			if(!isEmpty(pt1) || !isEmpty(pt2)){
				continue;
			}
			if( hasLine(pt0, pt1) && hasLine(pt1, pt2) && hasLine(pt2, pt3) ){
				score.step = score.type['noline'];
				return [pt0, pt1, pt2, pt3];
			}
	}
	//横向扫描可能的路径
	for(var k=0; k<X; k++){
			pt0 = p1;
			pt1 = {x:k, y:p1.y};
			pt2 = {x:k, y:p2.y};
			pt3 = p2;
			status = '(x:' + pt0.x + ',y:' + pt0.y + ')' + ', (x:' + pt1.x + ',y:' + pt1.y + ')' + ', (x:' + pt2.x + ',y:' + pt2.y + ')' + ', (x:' + pt3.x + ',y:' + pt3.y + ')';
			if(equal(pt0,pt1)){
				if(!isEmpty(pt2)){
					continue;
				}
				if( hasLine(pt1, pt2) && hasLine(pt2, pt3) ){
					score.step = score.type['muchline'];
					return [pt1, pt2, pt3];
				}
			}
			if(equal(pt2,pt3)){
				if(!isEmpty(pt1)){
					continue;
				}
				if( hasLine(pt0, pt1) && hasLine(pt1, pt2) ){
					return [pt0, pt1, pt2];
				}
			}
			if(!isEmpty(pt1) || !isEmpty(pt2)){
				continue;
			}
			if( hasLine(pt0, pt1) && hasLine(pt1, pt2) && hasLine(pt2, pt3) ){
				score.step = score.type['moreline'];
				return [pt0, pt1, pt2, pt3];
			}
	}
	//status='type4';
	return null;
	/********** end type 4 **************/
}

function equal(p1, p2){
	return ((p1.x==p2.x)&&(p1.y==p2.y));
}

function onlineX(p1, p2){
	return p1.y==p2.y;
}

function onlineY(p1, p2){
	return p1.x==p2.x;	
}

function isEmpty(p){
	return (arr[p.y][p.x]==0);	
}

function hasLine(p1, p2){
	if(p1.x==p2.x&&p1.y==p2.y){
		return true;	
	}
	if(onlineY(p1, p2)){
		var i = p1.y>p2.y?p2.y:p1.y;
		i = i+1;
		var max = p1.y>p2.y?p1.y:p2.y;
		for(; i<max; i++){
			var p = {x: p1.x, y: i};
			if(!isEmpty(p)){
				break
			}
		}
		if(i==max){
			return true;
		}
		return false;
	}
	else if(onlineX(p1, p2)){
		var j = p1.x>p2.x?p2.x:p1.x;
		j = j+1;
		var max = p1.x>p2.x?p1.x:p2.x;
		for(; j<max; j++){
			var p = {x: j, y: p1.y};
			if(!isEmpty(p)){
				break
			}
		}
		if(j==max){
			return true;
		}
		return false;
	}
}
/**
* js连连看完美注释版
* 原创作者: sunxing007(http://blog.csdn.net/sunxing007)
* 转载请注明出处
**/
//以下部分为表现层部分,包括绘图, 初始化矩阵, 绑定鼠标事件...
function $(id){
	return document.getElementById(id);
}

var t1, t2;//测试用
//图片基路径
var IMG_PATH = "./icon/", imgType = ".png";
//初始化
function init(){
	//构造图片库
	var imgs = new Array(30);
	for(var i=1; i<=30; i++){
		imgs[i] = i + imgType;
	}
	tbl = $('tbl');
	//构造table
	for(var row=0;row<Y-2;row++){
		var tr=tbl.insertRow(-1);
		for(var col=0;col<X-2;col++) {
			var td=tr.insertCell(-1);
		}
	}
	//构造矩阵
	for(var i=0; i<Y; i++){
		arr[i] = new Array(X);
		for(var j=0; j<X; j++){
			arr[i][j] = 0;
		}
	}
	var total = (X-2)*(Y-2);
	var tmp = new Array(total);//产生随机位置用
	for(var i=0; i<total; i++){
		tmp[i] = 0;
	}
	for(var i=0; i<total; i++){
		if(tmp[i]==0){
			var t = Math.floor(Math.random()*types) + 1;
			tmp[i] = t;
			while(true){
				var c = Math.floor(Math.random()*(total-i)) + i;
				if(tmp[c]==0){
					tmp[c] = t;
					break;
				}
			}
		}
	}
	var c = 0;
	for(var i=1; i<Y-1; i++){
		for(var j=1; j<X-1; j++){
			arr[i][j] = tmp[c++];
			tbl.rows[i-1].cells[j-1].innerHTML = '<img src="' + IMG_PATH + imgs[arr[i][j]] + '" />';
		}	
	}

/* 获得事件源dom对象 */
function getTarget(e) {
	e = e || window.event;
	var el = e.target || e.srcElement;
	return el;
};
/* 判断事件源是某个标签 */
function isTag(el, tagName) {
	return el.parentNode.tagName.toLowerCase() == tagName;
};

window.drawLine = {};
/* 画垂直线 */
drawLine.drawY = function(startPos, endPos){
	var height = MATH.abs(startPos.y - endPos.y);
};
/* 画横线 */


	//绑定鼠标事件
    var img1, img2;
	document.body.onclick = function(e){
		e = e || window.event;
		var el = e.target || e.srcElement;
		if(el.parentNode.tagName.toLowerCase()!='td'){
			return;
		};
		if(timer.isStop) {
			return;
		};
		if(!img1){
			img1 = el;
		}
		else{
			img2 = el;
		}
		el.style.borderColor = '#3399FF';
		el = el.parentNode;
		if(el.innerHTML==''){
			p1 = p2 = e1 = e2 = null;
		}
		var r = el.parentNode.rowIndex +1;
		var c = el.cellIndex +1;
		if(p1==null){
			//el.childNodes[0].style.border = 'solid #ccc 3px';
			p1 = {x:c, y:r};
			e1 = el;
		} else {
			p2 = {x:c, y:r};
			e2 = el;
			if(!equal(p1, p2)&&e1.innerHTML==el.innerHTML){
				var path = getPath(p1, p2);
				if(path!=null){
					e1.innerHTML = e2.innerHTML = '';
					arr[p1.y][p1.x] = arr[p2.y][p2.x] = 0;

					//消除成功后的回调 by ToFishes
					successCall();
				}
			}
			if(t1){t1.style.backgroundColor = '';}
			t1 = e1;
			if(t2){t2.style.backgroundColor = '';}
			t2 = e2;
			img1.style.borderColor = '#fff';
			img2.style.borderColor = '#fff';
			p1 = p2 = e1 = e2 = img1 = img2 = null;
			t1.style.backgroundColor = t2.style.backgroundColor = 'lightpink';
		};
		if(tbl.getElementsByTagName("img").length == 0) {
			timer.finish();
		}
	}
/**
* js连连看完美注释版
* 原创作者: sunxing007(http://blog.csdn.net/sunxing007)
* 转载请注明出处
**/
}

//TODO 倒计时，总时间1分钟，每消除一次增加10s。时间结束计分停。
//1、倒计时；2、ui体现
window.timer = {};
timer.totalTime = timer.leftTime = 100; //seconds
timer.increaseStep = 5;
timer.o = $("progress-inner");
timer.isStop = true;
timer.isFinished = false;
timer.progress = function(){
	timer.o.style.width = "" + (timer.leftTime / timer.totalTime) * 100 + "%";
	if(-- timer.leftTime < 0) {
		timer.finish();
	}
};
timer.progressTimeID = null;
timer.init = true;
timer.start = function(){
	timer.isStop = false;
	timer.progressTimeID = setInterval(function(){
		timer.progress();
	}, 1000);

	if(init) {
		var overlay = $('overlay');
		overlay && overlay.parentNode.removeChild(overlay);

		$('btn-play').className += " started";
		init = false;
	}
};
timer.stop = function(){
	timer.isStop = true;
	clearInterval(timer.progressTimeID);
};

timer.increase = function(){
	timer.leftTime += timer.increaseStep;
	if(timer.leftTime > timer.totalTime) {
		timer.leftTime = timer.totalTime;
	};
};
/**
  1、计时为0
  2、图片消除完毕

  完成后提交分数，显示提交按钮
*/
timer.finish = function(){
	timer.isFinished = true;
	$('btn-play').innerHTML = '结束';
	$('submit-score').style.display = 'inline';
	timer.stop();
};


//TODO 计分，每消除一次计分+10
//1、计分，2、ui显示，3、提交计分，有一个form表单显示
window.score = {};
score.totalScore = 0;
score.step = score.baseStep = 5;
score.type = {
	'oneline': score.baseStep - 2,
	'onlineX': score.baseStep - 1,
	'onlineY': score.baseStep - 1,
	'noline': score.baseStep,
	'nolineX': score.baseStep + 1,
	'nolineY': score.baseStep + 1,
	'muchline': score.baseStep + 2,
	'moreline': score.baseStep * 2
};
score.o = $("score");
score.input = $("score-param");
score.add = function(){
	if(! timer.isStop) {
		score.totalScore += score.step;
		score.o.innerHTML = score.totalScore;
		score.input.value = score.totalScore;	
	}
}
//消除成功后的回调
function successCall() {
	timer.increase();
	score.add();
};

function play(me){
	if(timer.isFinished) {
		return;
	};
	if(timer.isStop) {
		timer.start();
		me.innerHTML = "暂停";
	} else {
		timer.stop();
		me.innerHTML = "开始";
	};
}

</script>
</body>
</html>
